/////////////////////////////////////////////////////////////////////////////////////////
//                 University of Luxembourg  -
//                 Interdisciplinary center for Security and Trust (SnT)
//                 Copyright © 2016 University of Luxembourg, SnT
//
//
//  This library is free software; you can redistribute it and/or
//  modify it under the terms of the GNU Lesser General Public
//  License as published by the Free Software Foundation; either
//  version 3 of the License, or (at your option) any later version.
//
//  This library is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
//  Lesser General Public License for more details.
//
//  You should have received a copy of the GNU Lesser General Public
//  License along with this library; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
//
//
//    Author: Matthieu Jimenez – SnT – matthieu.jimenez@uni.lu
//
//////////////////////////////////////////////////////////////////////////////////////////
package lu.jimenez.research.bugsandvulnerabilities.collector.vulnerable

import lu.jimenez.research.bugsandvulnerabilities.collector.utils.Constants
import lu.jimenez.research.bugsandvulnerabilities.model.VulnerableFile
import lu.jimenez.research.bugsandvulnerabilities.model.internal.Document
import lu.jimenez.research.bugsandvulnerabilities.utils.MultiThreading
import lu.jimenez.research.bugsandvulnerabilities.utils.git.GitUtilitary
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.errors.GitAPIException
import org.eclipse.jgit.errors.MissingObjectException
import org.eclipse.jgit.revwalk.RevCommit
import org.python.core.PyDictionary
import org.python.core.PyInstance
import org.python.core.PyString
import org.python.util.PythonInterpreter
import java.io.File
import java.io.FileNotFoundException
import java.io.IOException
import java.util.*
import java.util.regex.Pattern

/**
 * Class to generate the set of vulnerability of a git repository
 *
 * Everything is based on CVE number
 *
 * @param path path to the git repository
 *
 * Relies on [Constants].YEAR_BEGINNING
 * [Constants].YEAR_END
 * [Constants].FILE_EXTENSION
 * [Constants].NB_THREAD
 */
class VulnerabilitySet(pathrepo : String) {
    val pathToRepo = pathrepo + ".git"

    /*************************************************************
     * Populating With CVE Database                              *
     *************************************************************/

    /**
     * Function to retrieve the vulnerabilities CVE/CWE with the hash of the patch from CVE XML Files
     * The files should be in the resources folder in the cveXML folder
     * line are using the following format:
     *  *CWE-XXX_CVE-XXXX-XXXX : commithash*
     */
    fun populateWithCVEDatabaseInfo(): MutableMap<String, String> {
        val commitWithCVE = HashMap<String, String>()
        val listOfYear = (Constants.YEAR_BEGINNING..Constants.YEAR_END - 1).toList()
        val listOfResultForAYear = MultiThreading.onFunctionWithSingleOutput(listOfYear, { year -> vulnerabilityperYear(year) }, Constants.NB_THREAD)
        listOfResultForAYear.forEach { resultyear -> commitWithCVE.putAll(resultyear) }
        return commitWithCVE
    }

    /*************************************************************
     * Populating With CVE present in git commit message         *
     * No Multithreading because python script                   *
     *************************************************************/
    /**
     * Function that looks in every comments of the git repo chosen for a mention to a CVE
     * Number. Verify that we don't already have it and add it to our dataset along with it CWE Number.
     */
    fun populateWithCVEPresentInCommit(registeredVulnerability: MutableMap<String, String> = HashMap()): MutableMap<String, String> {
        val git = Git.open(File(pathToRepo)) ?: throw FileNotFoundException(".git file not found")
        git.log().all().call().forEach { commit ->
            val result = processingCommitCVE(commit, registeredVulnerability)
            if (result != null) {
                registeredVulnerability.put(result[0], result[1])
            }

        }
        return registeredVulnerability
    }


    /**
     * Additional function that try to find commit mentionning vulnerabilit(y/ies)
     * store these commits
     */
    fun populateWithCommitContainingKeyword(alreadyRegisterVulnerability: MutableMap<String, String>): List<String?>? {

        try {
            val git = Git.open(File(pathToRepo))
            val commits = git.log().all().call().toList()
            return MultiThreading.onFunctionWithSingleOutput(commits, { commit -> processingCommitwithoutCVE(commit, alreadyRegisterVulnerability) }, Constants.NB_THREAD)
        } catch (e: IOException) {
            e.printStackTrace()
        } catch (e: GitAPIException) {
            e.printStackTrace()
        }
        return null
    }

    /**
     * Method to generate the whole set of vulnerable files by retrieving all of the files impacted by the previously found commit
     *
     */
    fun creatingVulnerableDataset(mapOfVulnCVE: MutableMap<String, String>, listOfAdditionalVulnerability: List<String?>? = null): List<VulnerableFile> {
        val listOfVulnerability = mutableListOf<VulnerableFile>()
        val listOfVulnerabilityalone = mutableListOf<VulnerableFile>()
        try {
            println("number of vuln ${mapOfVulnCVE.size} and ${listOfAdditionalVulnerability?.size}")
            val gitUtilitary = GitUtilitary(pathToRepo)
            listOfVulnerability.addAll(MultiThreading.onFunctionWithListOutput(mapOfVulnCVE.toList(), { entry -> generatingVulnerableFilesFromCVE(entry, gitUtilitary) }, Constants.NB_THREAD))
            if (listOfAdditionalVulnerability != null) {
                listOfVulnerabilityalone.addAll(MultiThreading.onFunctionWithListOutput(listOfAdditionalVulnerability, { commit -> generatingVulnerableFiles(commit!!, gitUtilitary) }, Constants.NB_THREAD))
            }
            gitUtilitary.close()
        } catch(e: IOException) {
            e.printStackTrace()
        }
        listOfVulnerability.addAll(listOfVulnerabilityalone)
        return listOfVulnerability
    }

    /**
     * Method to generate the vulnerable files out of a vulnerable commit when a cve number is availble
     *
     * @param entry pair of commit hash and cwe_cve
     * @param gitUtilitary
     *
     * @return list of vulnerable files of the commit
     */
    fun generatingVulnerableFilesFromCVE(entry: Pair<String, String>, gitUtilitary: GitUtilitary): List<VulnerableFile> {

        val cve = entry.second.split("_")[1]
        val cwe = entry.second.split("_")[0]
        val commitPatch = entry.first
        return generatingVulnerableFiles(commitPatch, gitUtilitary, cve, cwe)
    }

    /**
     *Method to generate the vulnerable files out of a vulnerable commit
     *
     * @param commitPatch commit that patch the vulnerability
     * @param gitUtilitary gitUtilitary object
     * @param cve if existing
     * @param cwe if existing
     *
     * @return list of vulnerable files of the commit
     * @throws MissingObjectException
     * @throws NullPointerException
     */
    fun generatingVulnerableFiles(commitPatch: String, gitUtilitary: GitUtilitary, cve: String? = null, cwe: String? = null): List<VulnerableFile> {
        val listOfVulnerability = mutableListOf<VulnerableFile>()
        try{
            val fullMessage = gitUtilitary.getCommitMessage(commitPatch)
            val time = gitUtilitary.getTimeCommit(commitPatch)
            val listOfModifiedFile = gitUtilitary.getListOfModifiedFile(commitPatch, Constants.FILE_EXTENSION)
            for (file in listOfModifiedFile) {
                val newName = file
                val previousCommit = gitUtilitary.previousCommitImpactingAFile(file, commitPatch)
                val oldname = previousCommit!!.filePath
                val oldHash = previousCommit.revCommit.name
                val oldTime = gitUtilitary.getTimeCommit(oldHash)
                val oldContent = gitUtilitary.retrievingFileFromSpecificCommit(oldHash, oldname)
                val newContent = gitUtilitary.retrievingFileFromSpecificCommit(commitPatch, newName)

                val vulnerableDoc = Document(oldname, oldTime, oldHash, oldContent)
                val patchedDoc = Document(newName, time, commitPatch, newContent)
                if (cve != null && cwe != null)
                    listOfVulnerability.add(VulnerableFile(vulnerableDoc, patchedDoc, fullMessage, true, cwe, cve))
                else listOfVulnerability.add(VulnerableFile(vulnerableDoc, patchedDoc, fullMessage, false))

            }}
        catch(e: MissingObjectException){println("$commitPatch doesn't exist")}
        catch(e: NullPointerException){println("$commitPatch doesn't exist")}
        return listOfVulnerability
    }

    /**
     * Companion object with some side Function use by function of VulnerabilitySetCreation.
     * The function doesn't require any acces to Vulnerability Set Creation and thus can be reused
     */
    companion object VulnerabilitySideFunction {
        /**
         * generate the hashmap of commit, CWE_CVE for a given year
         *
         * @param year under study
         * @return the hashmap of the corresponding year
         */
        fun vulnerabilityperYear(year: Int): HashMap<String, String> {
            val vulnerabilityOfTheYear = HashMap<String, String>()
            val listOfLinuxVulnerability = CVE_Parser(year).XMLparse().list
            for (vulnerability in listOfLinuxVulnerability) {
                val cve_commit = vulnerability.split(":");
                vulnerabilityOfTheYear.put(cve_commit[1].trim(), cve_commit[0].trim())
            }
            return vulnerabilityOfTheYear
        }

        /**
         * This function call the getCVE method of the Python Script present in the cve search library
         *
         * @param cve: cve number
         * *
         * @return String of the corresponding cwe
         */
        fun python_getCWE(cve: String): String {
            val props = Properties();
            props.setProperty("python.path", "${Constants.JYTHON}/Lib" +
                    ":${Constants.JYTHON}/Lib/site-packages" +
                    ":${Constants.JYTHON}/Lib/site-packages/pymongo-3.1.1-py2.7.egg" +
                    ":${Constants.JYTHON}/Lib/site-packages/redis-2.10.5-py2.7.egg");
            props.put("python.console.encoding", "UTF-8"); // Used to prevent: console: Failed to install '': java.nio.charset.UnsupportedCharsetException: cp0.
            props.put("python.security.respectJavaAccessibility", "false"); //don't respect java accessibility, so that we can access protected members on subclasses
            props.put("python.import.site", "true");
            PythonInterpreter.initialize(System.getProperties(),
                    props, arrayOf<String>())
            val interpreter = PythonInterpreter()
            val file = javaClass.classLoader.getResource("cvesearch/lib/Config.py")?.path ?: throw FileNotFoundException("Not finding Config.py")
            interpreter.execfile(file)
            try {
                val clas = interpreter.eval("Configuration()") as PyInstance
                val result = clas.invoke("getCVE", PyString(cve)) as PyDictionary
                if (result.containsKey("cwe"))
                    if (result["cwe"].toString() != "Unknown")
                        return result["cwe"].toString()
            } catch (e: ClassCastException) {
                error("$cve not found")
            } finally {
                return "CWE-0"
            }


        }

        /**
         * This function look for a CVE number in the full message of a commit
         * @param commit: commit under study
         * *
         * @return String Array (2 elements, the first one is the commit hash, the second one is cwe_cve
         */
        fun processingCommitCVE(commit: RevCommit, alreadyRegisterVulnerability: Map<String, String>): List<String>? {
            val pattern = Pattern.compile("[.|\\r|\\n]*(CVE[ ]?-[ ]?[0-9][0-9][0-9][0-9][ ]?-[ ]?[0-9][0-9][0-9][0-9])[.|\\r|\\n]*")
            if (!alreadyRegisterVulnerability.containsKey(commit.name)) {
                val m = pattern.matcher(commit.fullMessage)
                if (m.find() && !commit.fullMessage.contains("Merge")) {
                    val cwe = python_getCWE(m.group(1))
                    return listOf(commit.name, cwe + "_" + m.group(1))
                }
            }
            return null
        }

        /**
         * Function to look for the keyword vulnerability and/or vulnerabilities

         * @param commit under test
         * *
         * @return String commit hash
         */
        fun processingCommitwithoutCVE(commit: RevCommit, alreadyRegisterVulnerability: Map<String, String>): String? {
            if (!alreadyRegisterVulnerability.containsKey(commit.name)) {
                val message = commit.fullMessage.toLowerCase()
                if ((message.contains("vulnerability") || message.contains("vulnerabilities")) && !commit.fullMessage.contains("Merge")) {
                    return commit.name
                }
            }
            return null
        }

    }
}